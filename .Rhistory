total = upperStream)
fore$ForeCatch[min(which((fore$ForeCatch$Year==2021))):nrow(fore$ForeCatch),]<- tempForeCatch[,1:4]
writecatch <- fore$ForeCatch %>% filter(Year > 2020) %>% group_by(Year) %>% dplyr::summarise(Catch_Used = sum(Catch_or_F))
idx = nrow(writecatch)
writecatch[idx+1,'Year'] <- 2030
writecatch[idx+1,'Catch_Used'] <- upperStream
write.csv(writecatch,
file = "./tempForeCatch.csv",row.names = FALSE) ## save upperstream catched used
}
## save file
SS_writeforecastMK(fore, file = './forecast.ss', overwrite = TRUE)
## execute this model
setwd(newdir.temp); system('ss3 -nohess') ## works
} ## end states of nature
} ## end catch scenarios
## Run Const/Upper catch x 3 states ----
## Did these separately because the constant nature of the catch requires
## non-iteration. SS takes the input catches as gospel regardless of stock status.
rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/")
forecast_start <- 2021; forecast_end <- 2031; t = 10
## base M is -2.94, low is -2.99, high is -2.41
# for(r in c('North','Central','South')){ ## loop regions
for(catch in c('constant','upper')){ ## loop catch scen
for(state in c('low','base','high')){
df<-data.frame()
# rootdir.temp <- paste0(rootdir,"cr",r,"_ABC_",state) ## copy region & state
catch_projections <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/cproj_",r,".csv")) ## from base dir
Flimitfraction <- catch_projections$PSTAR_0.45[catch_projections$YEAR == 2030] ## doesn't really matter, already have catch vals
catch_proportions <- catch_projections[7,5:ncol(catch_projections)]
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
fixed_catches <- catch_projections[catch_projections$TYPE == 'ACTUAL',5:ncol(catch_projections)]
# replist0 <- SS_output(paste0(rootdir,"cr",r,"_ABC_base/base2015")) ## get values specific to this region
if(state != 'base'){
lastrun <- paste0(rootdir,"cr",r,"_ABC_",state)
} else if(state == 'base'){
lastrun <- paste0(rootdir,"cr",r,"_ABC_",state,"/forecasts/forecast",forecast_end)
}
mod1 <- SS_output(lastrun, covar = FALSE, hidewarn = T, verbose = F) ## just load once for structure this hasn't executed yet
newdir.temp <- paste0(rootdir,"cr",r,"_",catch,"_",state)
dir.create(newdir.temp) ## make special folder and copy files
file.copy(list.files(lastrun,
full.names = TRUE,
recursive = TRUE),
to = newdir.temp, overwrite = TRUE)
setwd(newdir.temp) ## now forecast2030 appropriate to state is replicated here
## only need to change catches in forecast file
fore <- SS_readforecastMK(file = './forecast.ss',
Nareas = mod1$nareas,
Nfleets = mod1$nfishfleets,
nseas = 1,
version = paste(mod1$SS_versionNumeric),
readAll = TRUE)
fore$vals_fleet_relative_f <- paste(paste0(catch_proportions, collapse = " "))
if(catch == 'constant'){
## apply 2019/2020 average to all yrs
tempForeCatch <- SS_ForeCatch(mod1,
yrs = forecast_start:(forecast_end-1),
average = FALSE,
total = const.catch)
fore$ForeCatch[min(which((fore$ForeCatch$Year==2021))):nrow(fore$ForeCatch),] <- tempForeCatch[,1:4]
writecatch <- fore$ForeCatch %>% filter(Year > 2020) %>% group_by(Year) %>% dplyr::summarise(Catch_Used = sum(Catch_or_F))
idx = nrow(writecatch)
writecatch[idx+1,'Year'] <- 2030
writecatch[idx+1,'Catch_Used'] <- const.catch
write.csv(writecatch,
file = "./tempForeCatch.csv",row.names = FALSE) ## save constant catched used
} else if (catch == 'upper'){
## apply 50% over 2021 to all years
upperStream <- 1.5*mod1$derived_quants[grep("ForeCatch_2021", mod1$derived_quants$Label),"Value"]
tempForeCatch <- SS_ForeCatch(mod1,
yrs =forecast_start:(forecast_end-1),
average = FALSE,
total = upperStream)
fore$ForeCatch[min(which((fore$ForeCatch$Year==2021))):nrow(fore$ForeCatch),]<- tempForeCatch[,1:4]
writecatch <- fore$ForeCatch %>% filter(Year > 2020) %>% group_by(Year) %>% dplyr::summarise(Catch_Used = sum(Catch_or_F))
idx = nrow(writecatch)
writecatch[idx+1,'Year'] <- 2030
writecatch[idx+1,'Catch_Used'] <- upperStream
write.csv(writecatch,
file = "./tempForeCatch.csv",row.names = FALSE) ## save upperstream catched used
}
## save file
SS_writeforecastMK(fore, file = './forecast.ss', overwrite = TRUE)
## execute this model
setwd(newdir.temp); system('ss3 -nohess') ## works
} ## end states of nature
} ## end catch scenarios
## Creation of objects for use in template ----
## mod RData
modN <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_base/forecasts/forecast2030"))
modC <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crCentral_ABC_base/forecasts/forecast2030"))
modS <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crSouth_ABC_base/forecasts/forecast2031"))
save(modN,modC,modS, file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
## Comparison plots
load(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
list(modN, modC, modS) %>% SSsummarize(.) %>%
r4ss::SSplotComparisons(shadeForecast = TRUE,
# subplots = 2,
endyrvec = 2030,
legendlabels = c("North",'Central','South'),
png = T, print = T,
plotdir =paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare"))
SSplotTimeseries(modS,subplot = 1)
mod.cols = c("#7570B3" ,"#D95F02","#1B9E77")
png(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare/yield_comparison_3_models.png"),
width = 8, height = 6, units = 'in', res = 520)
SSplotYield(modS, col= mod.cols[1], subplot=1)
grid()
SSplotYield(modN, col= mod.cols[2], subplot=1,add = TRUE)
SSplotYield(modC, col= mod.cols[3], subplot=1, add=TRUE)
legend('topright', legend=c('South','North','Central'), col=mod.cols, lwd=3, bg='white', bty='n', cex = 1.5)
dev.off()
## Build decision table (not in SS_executive summary) ----
YOI <- 2021:2030
# for(r in c('North','Central','South')){ ## loop regions
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",4))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",4))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",4))
## Build decision table (not in SS_executive summary) ----
YOI <- 2021:2030
# for(r in c('North','Central','South')){ ## loop regions
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'& r != 'South'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
} else if(catch == 'ABC' & r == 'South'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2031")
}
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2031/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
# for(r in c('North','Central','South')){ ## loop regions
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'& r != 'South'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
} else if(catch == 'ABC' & r == 'South'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2031")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2031/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
## rename to look nice
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",4))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",4))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",4))
dec_table
## save dec_table
write.csv(dec_table,
file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/txt_files/decision_table_",
r,".csv"),
row.names = F)
#Get the OFL catch data from each base model
OFL_N = modN$derived_quants[grep("OFL",modN$derived_quants$Label),]
OFL_N = OFL_N[,2]
OFL_C = modC$derived_quants[grep("OFL",modC$derived_quants$Label),]
OFL_C = OFL_C[,2]
OFL_S = modS$derived_quants[grep("OFL",modS$derived_quants$Label),]
OFL_S = OFL_S[,2]
#Turn into a dataframe and get the total
OFL = as.data.frame(cbind(OFL_N, OFL_C, OFL_S))
OFL$Total = rowSums(OFL)
OFL$Year= as.numeric(sub("^[^_]*_", "", modN$derived_quants[grep("OFL",modN$derived_quants$Label),'Label']))
OFL_S
modS$derived_quants[grep("OFL",modS$derived_quants$Label),]
modC$derived_quants[grep("OFL",modC$derived_quants$Label),]
OFL_S[-1,2]
odS$derived_quants[grep("OFL",modS$derived_quants$Label),]
modS$derived_quants[grep("OFL",modS$derived_quants$Label),]
modS$derived_quants[grep("OFL",modS$derived_quants$Label),][-1]
modS$derived_quants[grep("OFL",modS$derived_quants$Label),][-1,]
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
u
mod <- SS_output(tempdir, covar = F)
state = 'base'
catch = 'ABVC'
catch = 'ABC'
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
mod <- SS_output(tempdir, covar = F)
head(modS$derived_quants[grep("OFL",modS$derived_quants$Label),],-2) ##
head(mod$derived_quants[grep("OFL",mod$derived_quants$Label),],-2) ##
modS <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crSouth_ABC_base/forecasts/forecast2030"))
save(modN,modC,modS, file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
load(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
list(modN, modC, modS) %>% SSsummarize(.) %>%
r4ss::SSplotComparisons(shadeForecast = TRUE,
# subplots = 2,
endyrvec = 2030,
legendlabels = c("North",'Central','South'),
png = T, print = T,
plotdir =paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare"))
SSplotTimeseries(modS,subplot = 1)
mod.cols = c("#7570B3" ,"#D95F02","#1B9E77")
png(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare/yield_comparison_3_models.png"),
width = 8, height = 6, units = 'in', res = 520)
SSplotYield(modS, col= mod.cols[1], subplot=1)
grid()
SSplotYield(modN, col= mod.cols[2], subplot=1,add = TRUE)
SSplotYield(modC, col= mod.cols[3], subplot=1, add=TRUE)
legend('topright', legend=c('South','North','Central'), col=mod.cols, lwd=3, bg='white', bty='n', cex = 1.5)
dev.off()
## Build decision table (not in SS_executive summary) ----
YOI <- 2021:2030
# for(r in c('North','Central','South')){ ## loop regions
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'& r != 'South'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
} else if(catch == 'ABC' & r == 'South'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2031/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",4))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",4))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",4))
## save dec_table
write.csv(dec_table,
file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/txt_files/decision_table_",
r,".csv"),
row.names = F)
#Get the OFL catch data from each base model
OFL_N = modN$derived_quants[grep("OFL",modN$derived_quants$Label),]
OFL_N = OFL_N[,2]
OFL_C = modC$derived_quants[grep("OFL",modC$derived_quants$Label),]
OFL_C = OFL_C[,2]
OFL_S = modS$derived_quants[grep("OFL",modS$derived_quants$Label),] ## extra years in model run
OFL_S = OFL_S[,2]
#Turn into a dataframe and get the total
OFL = as.data.frame(cbind(OFL_N, OFL_C, OFL_S))
OFL$Total = rowSums(OFL)
OFL$Year= as.numeric(sub("^[^_]*_", "", modN$derived_quants[grep("OFL",modN$derived_quants$Label),'Label']))
save(modN,modC,modS, file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
modC$derived_quants[grep("OFL",modC$derived_quants$Label),]
modS$derived_quants[grep("OFL",modS$derived_quants$Label),]
#Get the OFL catch data from each base model
OFL_N = modN$derived_quants[grep("OFL",modN$derived_quants$Label),]
OFL_N = OFL_N[,2]
OFL_C = modC$derived_quants[grep("OFL",modC$derived_quants$Label),]
OFL_C = OFL_C[,2]
OFL_S = head(modS$derived_quants[grep("OFL",modS$derived_quants$Label),],-2) ## extra years in model run
OFL_S = OFL_S[,2]
#Turn into a dataframe and get the total
OFL = as.data.frame(cbind(OFL_N, OFL_C, OFL_S))
OFL$Total = rowSums(OFL)
OFL$Year= as.numeric(sub("^[^_]*_", "", modN$derived_quants[grep("OFL",modN$derived_quants$Label),'Label']))
OFL = OFL[OFL$Year < 2031,]
OFL <- OFL %>% select(Year, everything())
colnames(OFL) = c('Year','North','Central','South','Total')
## THIS IS DUPLICATED IN SUMMARY
OFL.table = xtable(round(subset(OFL, Year > 2020),2), caption=c("Projections of potential OFL (mt) for each model, using the base model forecast."),label = 'tab:OFL_projection')
#CHANGE ME
FirstYR=2019  # minimum year for the Spawning biomass table
LastYR=2030  # maximum year for the Spawning biomass table
###collect the data from all the tables
# read in the management table
# mngmt = read.csv("./txt_files/mngmt_performance_base.csv")
# mngmt = mngmt[,-1]
for (model in 1:n_models){
if(model==1){
mod=modN
mod_area='North'
} else {
if(model==2){
mod=modC
mod_area='Central'
} else {
mod=modS
mod_area='South'
}}
Year = FirstYR:LastYR
OFL <- mod$derived_quants[grep(paste0('OFLCatch_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
cp <- read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/cproj_",mod_area,".csv"))
## for all regions the ABC is the OFL * BUFFER
## for non-depleted regions the ACL will = the ABC which should be the OFL * buffer
if(mod_area != 'South'){
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
} else if(mod_area == 'South'){
## for depleted south they don't match so manually  saved ForeCatch_XXX from last model
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$ABC)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$FORECATCH_ACL)
}
Age5biomass = mod$timeseries[,c('Yr',"Bio_smry")]
Age5biomassyrs = subset(Age5biomass, Yr>=(FirstYR) & Yr<=(LastYR))
Age5biomassyrs = Age5biomassyrs[,2]
Age5biomassyrs = round(Age5biomassyrs,2)
SSB <- mod$derived_quants[grep(paste0('SSB_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
Depl <- mod$derived_quants[grep(paste0('Bratio_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
tableg <- round(cbind(Year, OFL, ABC_Landings,ACL_Landings, Age5biomassyrs, SSB,Depl),2) %>% data.frame(.) %>% mutate("Region" = rep(mod_area, length(Year)))
colnames(tableg) <- c('Year','Predicted OFL (mt)','ABC Catch (mt)', 'ACL Catch (mt)','Age 5+ Biomass (mt)', 'Spawning Biomass (mt)','Depletion', 'Region')
assign(paste('tableG_',mod_area,sep=''),tableg)
}
mod=modS
mod_area='South'
Year = FirstYR:LastYR
OFL <- mod$derived_quants[grep(paste0('OFLCatch_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
cp <- read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/cproj_",mod_area,".csv"))
## for non-depleted regions the ACL will = the ABC which should be the OFL * buffer
if(mod_area != 'South'){
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
} else if(mod_area == 'South'){
## for depleted south they don't match so manually  saved ForeCatch_XXX from last model
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$ABC)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$FORECATCH_ACL)
}
round(mod$derived_quants[grep(paste0('Bratio_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value'],3)
cbind(round(Year, OFL, ABC_Landings,ACL_Landings, Age5biomassyrs, SSB,2),Depl)
round(cbind(Year, OFL, ABC_Landings,ACL_Landings, Age5biomassyrs, SSB),2)
dec_table
require(r4ss)
?SSplotYield
## Comparison plots
load(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
mod.cols = c("#7570B3" ,"#D95F02","#1B9E77")
SSplotYield(modS, col= mod.cols[1], subplot=1)
?Abline
?abline
SSplotYield(modS, col= mod.cols[1], subplot=1)
abline(v = 0.2, add = T)
SSplotYield(modS, col= mod.cols[1], subplot=1)
abline(v = c(0.2,0.4), add = T, col = 'red')
SSplotYield(modS, col= mod.cols[1], subplot=2)
SSplotYield(modS, col= mod.cols[1], subplot=3)
SSplotYield(modS, col= mod.cols[1], subplot=4)
modS$derived_quants
modS$derived_quants[grep('SSB_2017',modS$derived_quants$Value),]
modS$derived_quants[grep('SSB_2017',modS$derived_quants$Value)]
modS$derived_quants[grep('SSB',modS$derived_quants$Value)]
modS$derived_quants[grep('SSB',modS$derived_quants$Value)]
modS$derived_quants[grepl('SSB',modS$derived_quants$Value)]
grepl('SSB',modS$derived_quants$Value)
grepl('SPB',modS$derived_quants$Value)
grepl('SSB_1994',modS$derived_quants$Value)
modS$derived_quants[grepl('SSB_1994',modS$derived_quants)
names(modS$derived_quants)
modS$derived_quants[grepl('SSB',modS$derived_quants$Label)]
modS$derived_quants[grepl('SSB',modS$derived_quants$Label),]
modS$derived_quants[grepl('SSB_2017',modS$derived_quants$Label),]
