dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
require(dplyr)
require(r4ss)
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
rootdir
rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/
")
read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
rootdir
rootdir <-"C:/Users/Maia Kapur/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/"
read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv")
read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
round(catchvals$FORECATCH_ACL,2)
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
round(catchvals$FORECATCH_ACL,2)
Flimitfraction
catch_projections$PSTAR_0.45[catch_projections$YEAR >2020]
devtools::install_github("mkapur/kaputils", dependencies = F)
devtools::install_github("mkapur/kaputils", dependencies = F)
library(kaputils)
state
SS_autoForecast(rootdir = rootdir.temp,
basedir = "base2015",
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)],
state = state,
statesex = 0,
statevals = cr.statevals,
forecast_start = 2021,
forecast_end = 2031,
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)],
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020])
rootdir.temp <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_",state)
rootdir.temp
SS_autoForecast(rootdir = rootdir.temp,
basedir = "base2015",
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)],
state = state,
statesex = 0,
statevals = cr.statevals,
forecast_start = 2021,
forecast_end = 2031,
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)],
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020])
devtools::install_github("mkapur/kaputils", dependencies = F)
# devtools::install_deps("C:/Users/mkapur/Dropbox/kaputils")
# devtools::install_github("mkapur/kaputils", dependencies = F)
library(kaputils)
SS_autoForecast(rootdir = rootdir.temp,
basedir = "base2015",
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)],
state = state,
statesex = 0,
statevals = cr.statevals,
forecast_start = 2021,
forecast_end = 2031,
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)],
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020])
SS_autoForecast(rootdir = rootdir.temp,
basedir = "base2015",
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)],
state = state,
statesex = 0,
statevals = cr.statevals,
forecast_start = 2021,
forecast_end = 2031,
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)],
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020])
read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
## Build decision table (not in SS_executive summary) ----
YOI <- 2021:2030
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
## rename to look nice
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",5))
dec_table
## save dec_table
write.csv(dec_table,
file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/txt_files/decision_table_",
r,".csv"),
row.names = F)
## Creation of objects for use in template ----
## mod RData
modN <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_base/forecasts/forecast2030"))
modC <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crCentral_ABC_base/forecasts/forecast2030"))
modS <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crSouth_ABC_base/forecasts/forecast2030"))
save(modN,modC,modS, file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
## Comparison plots
load(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
list(modN, modC, modS) %>% SSsummarize(.) %>%
r4ss::SSplotComparisons(shadeForecast = TRUE,
subplots = 2,
endyrvec = 2030,
legendlabels = c("North",'Central','South'),
png = F, print = F,
plotdir =paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare"))
SSplotTimeseries(modS,subplot = 1)
png(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare/yield_comparison_3_models.png"),
width = 8, height = 6, units = 'in', res = 520)
SSplotYield(modS, col= mod.cols[1], subplot=1)
grid()
SSplotYield(modN, col= mod.cols[2], subplot=1,add = TRUE)
SSplotYield(modC, col= mod.cols[3], subplot=1, add=TRUE)
legend('topright', legend=c('South','North','Central'), col=mod.cols, lwd=3, bg='white', bty='n', cex = 1.5)
dev.off()
SSplotYield(modS, col= mod.cols[1], subplot=1)
mod.cols[1]
mod.cols = c("#7570B3" ,"#D95F02","#1B9E77")
png(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare/yield_comparison_3_models.png"),
width = 8, height = 6, units = 'in', res = 520)
SSplotYield(modS, col= mod.cols[1], subplot=1)
grid()
SSplotYield(modN, col= mod.cols[2], subplot=1,add = TRUE)
SSplotYield(modC, col= mod.cols[3], subplot=1, add=TRUE)
legend('topright', legend=c('South','North','Central'), col=mod.cols, lwd=3, bg='white', bty='n', cex = 1.5)
dev.off()
graphics.off
graphics.off()
rootdir
rootdir.temp
rootdir=rootdir.temp
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(2029))), covar = FALSE) ## just load once
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",2028), covar = FALSE) ## just load once
SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = 14.44)
SS_ForeCatch(mod_prev,
yrs = 2021:2029, ## just do THIS year
average = FALSE,
total = 14.44)
SS_ForeCatch(mod_prev,
yrs = 2029, ## just do THIS year
average = FALSE,
total = 14.44)
SS_ForeCatch(mod_prev,
yrs = 2030, ## just do THIS year
average = FALSE,
total = 14.56)
modS <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crSouth_ABC_base/forecasts/forecast2031"))
r
## Build decision table (not in SS_executive summary) ----
YOI <- 2021:2030
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",5))
rootdir
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in c('constant','ABC','upper')){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in c('low','base','high')){
if(catch != 'ABC'  | state != 'base'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/cproj_",r,".csv"))
const.catch <- mean(rowSums(catch_projections[catch_projections$TYPE == 'PROJECTION',5:ncol(catch_projections)])) ## avg 2019/2020
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(const.catch,2)
} else if(catch == 'upper' & idxc ==2){
upperStream <- read.csv(paste0(tempdir,"/tempforecatch.csv"))
#1.5*mod$derived_quants[grep("ForeCatch_2021", mod$derived_quants$Label),"Value"]
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(upperStream[1,2],2)
} else if (catch == 'ABC' &  idxc ==2){
if(r != 'South') {
catchvals <- read.csv(paste0(rootdir,"/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$Catch_Used,2)
} else if(r == 'South'){
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(catchvals$FORECATCH_ACL,2)
# mod$timeseries[, grepl('Yr|dead[(]B', names(mod$timeseries))] %>%
# filter(Yr %in% YOI) %>%
# select(-Yr) %>% rowSums(.) %>% round(.,2)
}
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
## rename to look nice
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",5))
dec_table
modN <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_base/forecasts/forecast2030"))
modC <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crCentral_ABC_base/forecasts/forecast2030"))
modS <- SS_output(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crSouth_ABC_base/forecasts/forecast2031"))
save(modN,modC,modS, file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/China_SS_output2019.RData"))
png(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare/yield_comparison_3_models.png"),
width = 8, height = 6, units = 'in', res = 520)
SSplotYield(modS, col= mod.cols[1], subplot=1)
grid()
SSplotYield(modN, col= mod.cols[2], subplot=1,add = TRUE)
SSplotYield(modC, col= mod.cols[3], subplot=1, add=TRUE)
legend('topright', legend=c('South','North','Central'), col=mod.cols, lwd=3, bg='white', bty='n', cex = 1.5)
dev.off()
#CHANGE ME
FirstYR=2019  # minimum year for the Spawning biomass table
LastYR=2030  # maximum year for the Spawning biomass table
###collect the data from all the tables
# read in the management table
# mngmt = read.csv("./txt_files/mngmt_performance_base.csv")
# mngmt = mngmt[,-1]
for (model in 1:n_models){
if(model==1){
mod=modN
mod_area='North'
} else {
if(model==2){
mod=modC
mod_area='Central'
} else {
mod=modS
mod_area='South'
}}
Year = FirstYR:LastYR
OFL <- mod$derived_quants[grep(paste0('OFLCatch_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
cp <- read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/cproj_",mod_area,".csv"))
## for all regions the ABC is the OFL * BUFFER
## for non-depleted regions the ACL will = the ABC which should be the OFL * buffer
if(mod_area != 'South'){
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
} else if(mod_area == 'South'){
## for depleted south they don't match so manually  saved ForeCatch_XXX from last model
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$ABC)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$FORECATCH_ACL)
}
Age5biomass = mod$timeseries[,c('Yr',"Bio_smry")]
Age5biomassyrs = subset(Age5biomass, Yr>=(FirstYR) & Yr<=(LastYR))
Age5biomassyrs = Age5biomassyrs[,2]
Age5biomassyrs = round(Age5biomassyrs,2)
SSB <- mod$derived_quants[grep(paste0('SSB_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
Depl <- mod$derived_quants[grep(paste0('Bratio_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
tableg <- round(cbind(Year, OFL, ABC_Landings,ACL_Landings, Age5biomassyrs, SSB,Depl),2) %>% data.frame(.) %>% mutate("Region" = rep(mod_area, length(Year)))
colnames(tableg) <- c('Year','Predicted OFL (mt)','ABC Catch (mt)', 'ACL Catch (mt)','Age 5+ Biomass (mt)', 'Spawning Biomass (mt)','Depletion', 'Region')
assign(paste('tableG_',mod_area,sep=''),tableg)
}
n_models = 3
#CHANGE ME
FirstYR=2019  # minimum year for the Spawning biomass table
LastYR=2030  # maximum year for the Spawning biomass table
###collect the data from all the tables
# read in the management table
# mngmt = read.csv("./txt_files/mngmt_performance_base.csv")
# mngmt = mngmt[,-1]
for (model in 1:n_models){
if(model==1){
mod=modN
mod_area='North'
} else {
if(model==2){
mod=modC
mod_area='Central'
} else {
mod=modS
mod_area='South'
}}
Year = FirstYR:LastYR
OFL <- mod$derived_quants[grep(paste0('OFLCatch_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
cp <- read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/cproj_",mod_area,".csv"))
## for all regions the ABC is the OFL * BUFFER
## for non-depleted regions the ACL will = the ABC which should be the OFL * buffer
if(mod_area != 'South'){
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch.csv"))$Catch_Used)
} else if(mod_area == 'South'){
## for depleted south they don't match so manually  saved ForeCatch_XXX from last model
ABC_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$ABC)
ACL_Landings <- c( rowSums(cp[cp$TYPE == 'PROJECTION',5:ncol(cp)]) ,
read.csv(paste0(getwd(),"/cr",mod_area,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))$FORECATCH_ACL)
}
Age5biomass = mod$timeseries[,c('Yr',"Bio_smry")]
Age5biomassyrs = subset(Age5biomass, Yr>=(FirstYR) & Yr<=(LastYR))
Age5biomassyrs = Age5biomassyrs[,2]
Age5biomassyrs = round(Age5biomassyrs,2)
SSB <- mod$derived_quants[grep(paste0('SSB_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
Depl <- mod$derived_quants[grep(paste0('Bratio_',2019:2030,collapse = "|"),mod$derived_quants$Label),'Value']
tableg <- round(cbind(Year, OFL, ABC_Landings,ACL_Landings, Age5biomassyrs, SSB,Depl),2) %>% data.frame(.) %>% mutate("Region" = rep(mod_area, length(Year)))
colnames(tableg) <- c('Year','Predicted OFL (mt)','ABC Catch (mt)', 'ACL Catch (mt)','Age 5+ Biomass (mt)', 'Spawning Biomass (mt)','Depletion', 'Region')
assign(paste('tableG_',mod_area,sep=''),tableg)
}
#  create the Spawning biomass table
base_summary.table = xtable(rbind(tableG_North,tableG_Central,tableG_South), caption=c("China rockfish base case results summary."),    label='tab:base_summary',digits=0)
list(modN, modC, modS) %>% SSsummarize(.) %>%
r4ss::SSplotComparisons(shadeForecast = TRUE,
subplots = 2,
endyrvec = 2030,
legendlabels = c("North",'Central','South'),
png = F, print = F,
plotdir =paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare"))
png(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare/yield_comparison_3_models.png"),
width = 8, height = 6, units = 'in', res = 520)
SSplotYield(modS, col= mod.cols[1], subplot=1)
grid()
SSplotYield(modN, col= mod.cols[2], subplot=1,add = TRUE)
SSplotYield(modC, col= mod.cols[3], subplot=1, add=TRUE)
legend('topright', legend=c('South','North','Central'), col=mod.cols, lwd=3, bg='white', bty='n', cex = 1.5)
dev.off()
list(modN, modC, modS) %>% SSsummarize(.) %>%
r4ss::SSplotComparisons(shadeForecast = TRUE,
# subplots = 2,
endyrvec = 2030,
legendlabels = c("North",'Central','South'),
png = T, print = T,
plotdir =paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/r4ss/plots_compare"))
catchvals <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_base/forecasts/forecast2030/tempforecatch_OFL_ABC_ACL.csv"))
catchvals
dec_table
## save dec_table
write.csv(dec_table,
file = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/txt_files/decision_table_",
r,".csv"),
row.names = F)
